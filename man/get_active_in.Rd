% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/3_ant_admin.R
\name{get_active_in}
\alias{get_active_in}
\title{Removal of inactive inputs in a given model structure}
\usage{
get_active_in(sIn = NULL, fIn = NULL, args)
}
\arguments{
\item{sIn}{sIn an optional matrix of scalar input coordinates with all the orignal scalar input variables.}

\item{fIn}{an optional list of functional input coordinates with all the original functional input
variables.}

\item{args}{an object of class \code{"\linkS4class{modelCall}"}, which specifies the model structure for
which the active inputs should be extracted.}
}
\value{
An object of class \code{"list"}, containing the following information extracted from the
  \emph{args} parameter: (i) a \code{matrix} of scalar input variables kept active; and (ii) a \code{list}
  of functional input variables kept active.
}
\description{
The \link[funGp]{fgpm_factory} function returns an object of class \code{"\linkS4class{Xfgpm}"}
  with the function call of all the evaluated models stored in the \code{@log.success@args} and
  \code{@log.crashes@args} slots. The \code{get_active_in} function interprets the arguments linked to any
  structural configuration and returns a list with two elements: (i) a \code{matrix} of scalar input
  variables kept active; and (ii) a \code{list} of functional input variables kept active.
}
\examples{
# extracting the indices of the active inputs in an optimized model________________________
# generating input and output data
set.seed(100)
n.tr <- 32
sIn <- expand.grid(x1 = seq(0,1,length = n.tr^(1/5)), x2 = seq(0,1,length = n.tr^(1/5)),
                   x3 = seq(0,1,length = n.tr^(1/5)), x4 = seq(0,1,length = n.tr^(1/5)),
                   x5 = seq(0,1,length = n.tr^(1/5)))
fIn <- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut <- fgp_BB7(sIn, fIn, n.tr)
\donttest{
# optimizing the model structure with fgpm_factory (~12 seconds)
xm <- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut)

# indices of active inputs in the best model
xm@log.success@args[[1]] # the full fgpm call
which_on(sIn, fIn, xm@log.success@args[[1]]) # only the indices extracted bu which_on

# data structures of active inputs
active <- get_active_in(sIn, fIn, xm@log.success@args[[1]])
active$sIn.on # scalar data structures
active$fIn.on # functional data structures
}
\donttest{
# preparing new data for prediction based on inputs kept active____________________________
# generating input and output data
set.seed(100)
n.tr <- 32
sIn <- expand.grid(x1 = seq(0,1,length = n.tr^(1/5)), x2 = seq(0,1,length = n.tr^(1/5)),
                   x3 = seq(0,1,length = n.tr^(1/5)), x4 = seq(0,1,length = n.tr^(1/5)),
                   x5 = seq(0,1,length = n.tr^(1/5)))
fIn <- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut <- fgp_BB7(sIn, fIn, n.tr)

# optimizing the model structure with fgpm_factory (~12 seconds)
xm <- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut)

# identifying selected model and corresponding arguments in fgpm
opt.model <- xm@model
opt.args <- xm@log.success@args[[1]]

# generating input data for prediction
n.pr <- 243
sIn.pr <- expand.grid(x1 = seq(0,1,length = n.pr^(1/5)), x2 = seq(0,1,length = n.pr^(1/5)),
                      x3 = seq(0,1,length = n.pr^(1/5)), x4 = seq(0,1,length = n.pr^(1/5)),
                      x5 = seq(0,1,length = n.pr^(1/5)))
fIn.pr <- list(f1 = matrix(runif(n.pr*10), ncol = 10), f2 = matrix(runif(n.pr*22), ncol = 22))

# prunning data structures for prediction to keep only active inputs
active <- get_active_in(sIn.pr, fIn.pr, opt.args)

# making predictions
preds <- predict(opt.model, sIn.pr = active$sIn.on, fIn.pr = active$fIn.on)

# plotting predictions
plotPreds(opt.model, preds = preds)
}

}
\references{
Betancourt, J., Bachoc, F., and Klein, T. (2020),
R Package Manual: "Gaussian Process Regression for Scalar and Functional Inputs with funGp - The in-depth tour".
\emph{RISCOPE project}.
\href{https://hal.archives-ouvertes.fr/hal-02536624}{[HAL]}
}
\seealso{
\strong{*} \link[funGp]{which_on} for details how to obtain only on the indices of the active inputs.

\strong{*} \code{"\linkS4class{modelCall}"} for details on the \emph{args} argument.

\strong{*} \link[funGp]{fgpm_factory} for funGp heuristic model selection.

\strong{*} \code{"\linkS4class{Xfgpm}"} for details on object delivered by \link[funGp]{fgpm_factory}.
}
\author{
José Betancourt, François Bachoc and Thierry Klein
}
