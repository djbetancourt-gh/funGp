% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/1_Xfgpm_Class.R
\name{fgpm_factory}
\alias{fgpm_factory}
\title{Structural optimization of Gaussian process models}
\usage{
fgpm_factory(
  sIn = NULL,
  fIn = NULL,
  sOut = NULL,
  ind.vl = NULL,
  ctraints = list(),
  setup = list(),
  time.lim = Inf,
  nugget = 1e-08,
  n.starts = 1,
  n.presample = 20,
  par.clust = NULL,
  trace = TRUE,
  pbars = interactive()
)
}
\arguments{
\item{sIn}{An optional matrix of scalar input values to train the model. Each column must match an input
variable and each row a training point. Either scalar input coordinates (sIn), functional input
coordinates (fIn), or both must be provided.}

\item{fIn}{An optional list of functional input values to train the model. Each element of the list must
be a matrix containing the set of curves corresponding to one functional input. Either scalar input
coordinates (sIn), functional input coordinates (fIn), or both must be provided.}

\item{sOut}{A vector (or 1-column matrix) containing the values of the scalar output at the specified
input points.}

\item{ind.vl}{An optional numerical matrix specifying which points in the three structures above should be
used for training and which for validation. If provided, the optimization will be conducted in terms of
the hold-out coefficient of determination Q², which comes from training the model with a subset of the points, and then estimating the
prediction error in the remaining points. In that case, each column of \emph{ind.vl} will be interpreted
as one validation set, and the multiple columns will imply replicates. In the simplest case,
\emph{ind.vl} will be a one-column matrix or simply an array, meaning that a simple replicate should be
used for each model configuration explored. If not provided, the optimization will be conducted in terms
of the leave-one-out cross-validation Q², which for a total number of n observations, comes from training
the model n times, each using n-1 points for training and the remaining one for validation. This procedure
is typically costly due to the large number of hyperparameter optimizations that should be conducted,
nonetheless, fgpm_factory implements the virtual equations introduced by Dubrule (1983) for Gaussian
processes, which require a single hyperparameter optimization. See the reference below for more details.}

\item{ctraints}{An optional list specifying the constraints of the structural optimization problem. Valid
entries for this list are: \cr\cr
\strong{*}\emph{s_keepOn}: a numerical array indicating the scalar inputs that should remain active in the
  model. It should contain the indices of the columns of sIn corresponding to the inputs to keep active. \cr\cr
\strong{*}\emph{f_keepOn}: a numerical array indicating the functional inputs that should remain active in
  the model. It should contain the indices of the elements of fIn corresponding to the inputs to keep active. \cr\cr
\strong{*}\emph{f_disTypes}: a list specifying the set of distances that should be tested for some
  functional inputs. The values should be taken from the possibilities offered by the \link[funGp]{fgpm}
  function for the argument \emph{f_disType} therein. Valid choices at this time are "L2_bygroup" and
  "L2_byindex". Each element of the list should receive as name the index of a functional input variable,
  and should contain an array of strings with the name of the distances allowed for this input. All the
  available distances will be tried for any functional input not included in the list. \cr\cr
\strong{*}\emph{f_fixDims}: a two-row matrix specifying a particular projection dimension for some
  functional inputs. For each input, the value should be a number between 0 and its original dimension,
  with 0 denoting no projection. The first row of the matrix should contain the index of each input, and
  the second row should contain the corresponding dimensions. All the possible dimensions will be tried
  for any functional input not included in the matrix (unless affected by the \emph{f_maxDims} argument
  below). \cr\cr
\strong{*}\emph{f_maxDims}: a two-row matrix specifying the largest projection dimension for some
  functional inputs. For each input, the value should be a number between 1 and its original dimension.
  The first row of the matrix should contain the index of each input, and the second row should contain
  the corresponding largest dimensions. All the possible dimensions will be tried for any functional input
  not included in the matrix (unless affected by the \emph{f_fixDims} argument above). \cr\cr
\strong{*}\emph{f_basTypes}: a list specifying the set of basis families that should be tested for some
  functional inputs. The values should be taken from the possibilities offered by the \link[funGp]{fgpm}
  function for the argument \emph{f_basType} therein. Valid choices at this time are "B-splines" and "PCA".
  Each element of the list should receive as name the index of a functional input variable, and should
  contain an array of strings with the name of the distances allowed for this input. All the available
  basis families will be tried for any functional input not included in the list. \cr\cr
\strong{*}\emph{kerTypes}: an array of strings specifying the kernel functions allowed to be tested. The
  values should be taken from the possibilities offered by the \link[funGp]{fgpm} function for the argument
  \emph{kerType} therein. Valid choices at this time are "gauss", "matern5_2" and "matern3_2". If not
  provided, all the available kernel functions will be tried.}

\item{setup}{An optional list indicating the value for some parameters of the structural optimization
algorithm. The ant colony optimization algorithm available at this time allows the following entries: \cr\cr
\strong{Initial pheromone load}\cr\cr
  \strong{*}\emph{tao0}: a number indicating the initial pheromone load on links pointing out to the
    selection of a distance type, a projection basis or a kernel type. Default is 0.1. \cr\cr
  \strong{*}\emph{dop.s}: a number controlling how likely it is to activate a scalar input. It operates on a
    relation of the type \eqn{A  = dop.s * I}, where \emph{A} is the initial pheromone load of links
    pointing out to the activation of scalar inputs and \emph{I} is the initial pheromone load of links
    pointing out to their inactivation. Default is 1. \cr\cr
  \strong{*}\emph{dop.f}: analogous to \emph{dop.s} for functional inputs. Default is 1. \cr\cr
  \strong{*}\emph{delta.f and dispr.f}: two numbers used as shape parameters for the regularization
    function that determines the initial pheromone values on the links connecting the L2_byindex distance
    with the projection dimension. Default are 2 and 1.4, respectively. \cr\cr
\strong{Local pheromone update}\cr\cr
  \strong{*}\emph{rho.l}: a number specifying the pheromone evaporation rate. Default is 0.1. \cr\cr
\strong{Global pheromone update}\cr\cr
  \strong{*}\emph{u.gbest}: a boolean indicating if at each iteration, the pheromone load on the links
    of the best ant of the whole trial should be reinforced. Default is FALSE. \cr\cr
  \strong{*}\emph{n.ibest}: a number indicating how many top ants of each iteration should be used for
    pheromone reinforcement. Default is 1. \cr\cr
  \strong{*}\emph{rho.g}: a number specifying the learning reinforcement rate. Default is 0.1. \cr\cr
\strong{Population factors}\cr\cr
  \strong{*}\emph{n.iter}: a number specifying the amount of iterations of the algorithm. Default is 15. \cr\cr
  \strong{*}\emph{n.pop}: a number specifying the amount of ants per iteration; each ant corresponds to one
    structural configuration for the model. Default is 10. \cr\cr
\strong{Bias strength}\cr\cr
  \strong{*}\emph{q0}: ants use one of two rules to select their next node at each step. The first rule leads
    the ant through the link with higher pheromone load; the second rule works based on probabilities which
    are proportional to the pheromone load on the feasible links. The ants will randomly chose one of the two
    rules at each time. They will opt for rule 1 with probability \emph{q0}. Default is 0.95.}

\item{time.lim}{An optional number specifying a time limit in seconds to be used as stopping condition for the
structural optimization.}

\item{nugget}{An optional variance value standing for the homogeneous nugget effect. A tiny nugget might help
to overcome numerical problems related to the ill-conditioning of the covariance matrix. Default is 1e-8.}

\item{n.starts}{An optional integer indicating the number of initial points to use for the optimization of the
hyperparameters. A parallel processing cluster can be exploited in order to speed up the evaluation of
multiple initial points. More details in the description of the argument par.clust below. Default is 1.}

\item{n.presample}{An optional integer indicating the number of points to be tested in order to select the
n.starts initial points. The n.presample points will be randomly sampled from the hyper-rectangle defined by: \cr \cr
1e-10 \eqn{\le} \code{ls_s.hyp[i]} \eqn{\le} 2*max(\code{sMs[[i]]}), for i in 1 to the number of scalar inputs, \cr
1e-10 \eqn{\le} \code{ls_f.hyp[i]} \eqn{\le} 2*max(\code{fMs[[i]]}), for i in 1 to the number of functional inputs, \cr \cr
with  sMs and fMs the lists of distance matrices for the scalar and functional inputs, respectively. The value of
n.starts will be assigned to n.presample if this last is smaller. Default is 20.}

\item{par.clust}{An optional parallel processing cluster created with the \code{\link[parallel]{makeCluster}}
function of the \link[=parallel]{parallel package}. If not provided, structural configurations are evaluated in
sequence.}

\item{trace}{An optional boolean indicating if control messages native of the \link[=funGp-package]{funGp package} should be
printed to console. Default is TRUE. For complementary control on the display of funGp-native progress bars, have a look at
the \code{pbars} argument below.}

\item{pbars}{An optional boolean indicating if progress bars should be displayed. Default is TRUE.}
}
\value{
An object of class \linkS4class{Xfgpm} containing the data structures linked to the structural optimization
  of a funGp model. It includes as the main component an object of class \linkS4class{fgpm} corresponding to the
  optimized model. It is accessible through the \code{@model} slot of the Xfgpm object.
}
\description{
This function enables the smart exploration of the solution space of potential structural
  configurations of a funGp model, and the consequent selection of a high quality configuration. funGp
  currently relies on an ant colony based algorithm to perform this task. The algorithm defines the
  solution space based on the levels of each structural parameter currently available in the
  \link[funGp]{fgpm} function, and performs a smart exploration of it. More details on the algorithm are
  provided in a dedicated
  \href{https://hal.archives-ouvertes.fr/hal-02532713}{technical report}.
  funGp might evolve in the future to include improvements in the current algorithm or alternative
  solution methods.
}
\examples{
#construction of a fgpm object
set.seed(100)
n.tr <- 32
x1 <- x2 <- x3 <- x4 <- x5 <- seq(0,1,length = n.tr^(1/5))
sIn <- expand.grid(x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = x5)
fIn <- list(f1 = matrix(runif(n.tr * 10), ncol = 10),
            f2 = matrix(runif(n.tr * 22), ncol = 22))
sOut <- fgp_BB7(sIn, fIn, n.tr)

# optimizing the model structure with fgpm_factory (~12 seconds)
\dontrun{
xm <- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut)
}

# assessing the quality of the model
# in the absolute and also w.r.t. the other explored models
plot(xm, which = "diag")

# checking the evolution of the algorithm
plot(xm, which = "evol")

# Summary of the tested configurations
summary(xm)

# checking the log of crashed iterations
print(xm@log.crashes)

# building the model with the default fgpm arguments to compare
set.seed(100)
n.tr <- 32
x1 <- x2 <- x3 <- x4 <- x5 <- seq(0,1,length = n.tr^(1/5))
sIn <- expand.grid(x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = x5)
fIn <- list(f1 = matrix(runif(n.tr * 10), ncol = 10),
f2 <- matrix(runif(n.tr * 22), ncol = 22))
sOut <- fgp_BB7(sIn, fIn, n.tr)
m1 <- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)
plot(m1) # plotting the model

# improving performance with more iterations_______________________________________________
# call to fgpm_factory (~22 seconds)
\dontrun{
xm25 <- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut,
                     setup = list(n.iter = 25))
}

# assessing evolution and quality
plot(xm25, which = "evol")
plot(xm25, which = "diag")

# custom solution space____________________________________________________________________
myctr <- list(s_keepOn = c(1,2), # keep both scalar inputs always on
f_keepOn = c(2), # keep f2 always active
f_disTypes = list("2" = c("L2_byindex")), # only use L2_byindex distance for f2
f_fixDims = matrix(c(2,4), ncol = 1), # f2 projected in dimension 4
f_maxDims = matrix(c(1,5), ncol = 1), # f1 projected in dimension max 5
f_basTypes = list("1" = c("B-splines")), # only use B-splines projection for f1
kerTypes = c("matern5_2", "gauss")) # test only Matern 5/2 and Gaussian kernels
#
# call to fgpm_factory (~12 seconds)
\dontrun{
xmc <- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut, ctraints = myctr)
}

# assessing evolution and quality
plot(xmc, which = "evol")
plot(xmc, which = "diag")

# verifying constraints with the log of some successfully built models
summary(xmc)

# custom heuristic parameters______________________________________________________________
mysup <- list(n.iter = 30, n.pop = 12, tao0 = .15, dop.s = 1.2,
              dop.f = 1.3, delta.f = 4, dispr.f = 1.1, q0 = .85,
              rho.l = .2, u.gbest = TRUE, n.ibest = 2, rho.g = .08)

# call to fgpm_factory (~20 seconds)
\dontrun{
xmh <- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut, setup = mysup)
}

# verifying heuristic setup through the details of the Xfgpm object
unlist(xmh@details$param)

# stopping condition based on time_________________________________________________________
mysup <- list(n.iter = 2000)
mytlim <- 60

# call to fgpm_factory (~60 seconds)
\dontrun{
xms <- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut,
                    setup = mysup, time.lim = mytlim)
}
summary(xms)

\dontrun{
# parallelization in the model factory_____________________________________________________
# generating input and output data
set.seed(100)
n.tr <- 243
sIn <- expand.grid(x1 = seq(0,1,length = n.tr^(1/5)), x2 = seq(0,1,length = n.tr^(1/5)),
                   x3 = seq(0,1,length = n.tr^(1/5)), x4 = seq(0,1,length = n.tr^(1/5)),
                   x5 = seq(0,1,length = n.tr^(1/5)))
fIn <- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut <- fgp_BB7(sIn, fIn, n.tr)

# calling fgpm_factory in parallel
cl <- parallel::makeCluster(2)
xm.par <- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut, par.clust = cl) #  (~260 seconds)
parallel::stopCluster(cl)

# NOTE: in order to provide progress bars for the monitoring of time consuming processes
#       ran in parallel, funGp relies on the doFuture and future packages. Parallel processes
#       suddenly interrupted by the user tend to leave corrupt connections. This problem is
#       originated outside funGp, which limits our control over it. In the manual
#       of funGp, we provide a temporary solution to the issue and we remain attentive in
#       case it appears a more elegant way to handle it or a manner to suppress it.
#
#       funGp manual: https://hal.archives-ouvertes.fr/hal-02536624
}

}
\references{
Betancourt, J., Bachoc, F., Klein, T., Idier, D., Pedreros, R., and Rohmer, J. (2020),
"Gaussian process metamodeling of functional-input code for coastal flood hazard assessment".
\emph{Reliability Engineering & System Safety}, \strong{198}, 106870.
\href{https://www.sciencedirect.com/science/article/abs/pii/S0951832019301693}{[RESS]}
\href{https://hal.archives-ouvertes.fr/hal-01998724}{[HAL]}

Betancourt, J., Bachoc, F., Klein, T., and Gamboa, F. (2020),
Technical Report: "Ant Colony Based Model Selection for Functional-Input Gaussian Process Regression. Ref. D3.b (WP3.2)".
\emph{RISCOPE project}.
\href{https://hal.archives-ouvertes.fr/hal-02532713}{[HAL]}

Betancourt, J., Bachoc, F., and Klein, T. (2020),
R Package Manual: "Gaussian Process Regression for Scalar and Functional Inputs with funGp - The in-depth tour".
\emph{RISCOPE project}.
\href{https://hal.archives-ouvertes.fr/hal-02536624}{[HAL]}

Dubrule, O. (1983),
"Cross validation of kriging in a unique neighborhood".
\emph{Journal of the International Association for Mathematical Geology}, \strong{15},  687-699.
\href{https://link.springer.com/article/10.1007/BF01033232}{[MG]}
}
\seealso{
\strong{*} \link[funGp]{plot,Xfgpm-method} with
    \code{which = "evolution"} for visualizing the evolution of
    the ACO algorithm, or with \code{which = "diag"} for a
    diagnostic plot;

\strong{*} \link[funGp]{get_active_in} for post-processing
    of input data structures following a fgpm_factory call;

\strong{*} \link[funGp]{predict,fgpm-method} for
    predictions based on a funGp model;

\strong{*} \link[funGp]{simulate,fgpm-method} for
    simulations based on a funGp model;

\strong{*} \link[funGp]{update,fgpm-method} for
    post-creation updates on a funGp model.
}
\author{
José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
}
