% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/2_funGp_Class.R
\name{funGp}
\alias{funGp}
\title{Fitting of functional-input Gaussian process models}
\usage{
funGp(
  sIn = NULL,
  fIn = NULL,
  sOut,
  doProj = T,
  fpDims = NULL,
  kerType = "matern5_2",
  disType = "functional",
  var.hyp = NULL,
  ls_s.hyp = NULL,
  ls_f.hyp = NULL,
  n.starts = 1,
  n.presample = 20
)
}
\arguments{
\item{sIn}{a matrix of scalar input values to train the model. Each column must match an input variable
and each row a training point.}

\item{fIn}{a list of functional inputs values to fit the model. Each element of the list must contain a
matrix.}

\item{sOut}{a vector (or 1-column matrix) containing the values of the scalar output at the training
points.}

\item{doProj}{a boolean indicating whether a projection of the inputs should be done for dimension
reduction.}

\item{fpDims}{an optional array with the projection dimension for each functional input.}

\item{kerType}{an optional character specifying the covariance structure to be used. To be chosen between
"gauss", "matern5_2" and "matern3_2". Default is "matern5_2".}

\item{disType}{an optional character specifying the distance function to use for the functional inputs
within the covariance function. To be chosen between "scalar" and "functional". Default is "functional".}

\item{var.hyp}{fill!!!!!!}

\item{ls_s.hyp}{fill!!!!!!}

\item{ls_f.hyp}{fill!!!!!!}

\item{n.starts}{Fill!!!!!!!!!!}

\item{n.presample}{Fill!!!!!!!!!!}
}
\description{
Creates a Gaussian process model based on the nature of the inputs which could be scalar,
functional or hybrid. For functional inputs, the user might specify a projection method, projection
dimension and distance type seeking for optimal processing time or metamodel predictability.
}
\examples{
set.seed(100)
n.tr <- 25
sIn <- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn <- list(f1 = matrix(runif(n.tr*10), ncol = 10), matrix(runif(n.tr*22), ncol = 22))

# generating output data for training
sOut <- as.matrix(sapply(t(1:n.tr), function(i){
  x1 <- sIn[i,1]
  x2 <- sIn[i,2]
  f1 <- fIn[[1]][i,]
  f2 <- fIn[[2]][i,]
  t1 <- seq(0,1,length = length(f1))
  t2 <- seq(0,1,length = length(f2))
  as.numeric(x1 + 2 * x2 + 4 * mean(t1 * f1) + mean(f2))
}))

# creating a funGp model
m1 <- funGp(sIn = sIn, fIn = fIn, sOut = sOut)

# plotting the model
plotLOO(m1)

}
\author{
José Betancourt, François Bachoc and Thierry Klein
}
