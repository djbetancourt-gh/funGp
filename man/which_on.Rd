% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/3_ant_admin.R
\name{which_on}
\alias{which_on}
\title{Indices of active inputs in a given model structure}
\usage{
which_on(sIn = NULL, fIn = NULL, args)
}
\arguments{
\item{sIn}{sIn an optional matrix of scalar input coordinates with all the orignal scalar input variables.
This is used only to know the total number of scalar input variables. Any \code{matrix} with as many
columns as original scalar input variables could be used instead.}

\item{fIn}{an optional list of functional input coordinates with all the original functional input
variables. This is used only to know the total number of functional input variables. Any \code{list}
with as many elements as original functional input variables could be used instead.}

\item{args}{an object of class \code{"\linkS4class{modelCall}"}, which specifies the model structure for
which the active inputs should be extracted.}
}
\value{
An object of class \code{"list"}, containing the following information extracted from the
  \emph{args} parameter: (i) an array of indices of the scalar inputs kept active; and (ii) an array of
  indices of the functional inputs kept active.
}
\description{
The \link[funGp]{fgpm_factory} function returns an object of class \code{"\linkS4class{Xfgpm}"}
  with the function call of all the evaluated models stored in the \code{@log.success@args} and
  \code{@log.crashes@args} slots. The \code{which_on} function interprets the arguments linked to any
  structural configuration and returns a list with two elements: (i) an \code{array} of indices of the scalar
  inputs kept active; and (ii) an \code{array} of indices of the functional inputs kept active.
}
\examples{
# extracting the indices of the active inputs in an optimized model________________________
# generating input and output data
set.seed(100)
n.tr <- 32
sIn <- expand.grid(x1 = seq(0,1,length = n.tr^(1/5)), x2 = seq(0,1,length = n.tr^(1/5)),
                   x3 = seq(0,1,length = n.tr^(1/5)), x4 = seq(0,1,length = n.tr^(1/5)),
                   x5 = seq(0,1,length = n.tr^(1/5)))
fIn <- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut <- fgp_BB7(sIn, fIn, n.tr)
\donttest{
# optimizing the model structure with fgpm_factory (~12 seconds)
xm <- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut)

# active inputs in the best model
xm@log.success@args[[1]] # the full fgpm call
which_on(sIn, fIn, xm@log.success@args[[1]]) # only the indices extracted bu which_on
}

}
\references{
Betancourt, J., Bachoc, F., and Klein, T. (2020),
R Package Manual: "Gaussian Process Regression for Scalar and Functional Inputs with funGp - The in-depth tour".
\emph{RISCOPE project}.
\href{https://hal.archives-ouvertes.fr/hal-02536624}{[HAL]}
}
\seealso{
\strong{*} \link[funGp]{get_active_in} for details how to obtain the data structures linked to the
active inputs.

\strong{*} \linkS4class{modelCall} for details on the \emph{args} argument.

\strong{*} \link[funGp]{fgpm_factory} for funGp heuristic model selection.

\strong{*} \linkS4class{Xfgpm} for details on object delivered by \link[funGp]{fgpm_factory}.
}
\author{
José Betancourt, François Bachoc and Thierry Klein
}
